# sed
> 就从你下手了

- 流编辑器
- 可以直接通过管道过滤文本,比一般的文本编辑器好在这里

运行
---
- 一般语法:
```
sed SCRIPT INPUTFILE...
```
- 未指定输入文件或者输入文件指定为`-`,过滤标准输出
- `-i`(in-place),不打印输出(直接修改输入文件)
- `-n`抑制输出(专门打印的就可以很容易分了)
- sed将多个输出文件看做**一个**长的流
- 没有`-e`或者`-f`选项,将第一个参数用作脚本,之后的非选项参数用作输入文件
- `-e`行内指定,`-f`指定文件
- `-l N`,`--line-length=N`,指定默认折行长度,默认70
- `-b`,在这里是没有用的
- `--follow-symlinks`,跟进符号链接
- `-E`,`-r`,`--regexp-extended`,使用拓展正则
- `-s`,多个输入各当做单独的文件
- `--sandbox`,抵制`e/w/r`命令
- `-u`尽可能减少输入输出的缓冲
- `-z`,使用的输入行是`\0`结尾的,而不是`\n`

退出状态
---
- 0: 正常
- 1: 命令,语法,正则不正确或者在`--posix`的时候使用了gnu拓展
- 2: 一个或者多个输入文件不能打开
- 4: I/O错误.或者严重的处理错误,立即退出
- ?: 使用q命令以任意值退出退出

脚本
---
- `sed`命令语法:
```
[addr]X[options]
```
- `X`是一个单字符sed命令
- `[addr]`是可选的行地址,可以是:
	- 单个行号
	- 正则表达式
	- 行范围
- `[options]`,某些sed命令会使用
- 删除输入中的30-35行(vim就是抄这个的吧..)
```
sed '30,35d' input.txt > output.txt
```
- 碰到`foo`开头的行退出:
```
sed '/^foo/q42' input.txt > output.txt
```
- 命令可以使用`;`或者`\n`退出,a,c,i因为他们的语法不能使用`;`

sed命令总结
---
`a\

text`: 行后追加文本
- `a text`: 行后追加文本
- `b label`: 切换到`label`.可以缺省label,然后开始下一循环
- `c text`: 使用text替换行(还有和`a`那个一样的语法)
- `d`: 删除模,立即开始下一个循环
- `D`: 如果模中有新行,删除到第一个换行,使用剩下的模重新循环
- `e`: 执行在模中找到的命令然后使用输出替换模,末尾的换行会被砍掉
- `e command`: 执行命令然后将它的输出送到输出流
- `F`: 打印当前输入文件的文件名,带换行
- `g`: 在模末尾追加换行,然后将暂存空间的内容追加到模
- `h`: 使用模的内容替换暂存空间的内容
- `H`: 在暂存空间后追加一个换行,然后将模的内容追加到暂存空间
> hold,就是将模暂存

- `i text`: 将text插入到一个行之前(还有类似a的语法)
- `l`: 以明确的形式打印模内容
- `n`: 如果没有关闭自动打印,打印模,然后,使用输入中的下一行替换模.如果没有输入行了就退出
- `N`: 添加一个换行到模,然后将输入中下一行追加到模
- `p`: 打印模
- `P`: 打印模,直到第一个换行
- `q[exit-code]`: 退出
- `Q[exit-code]`: 类似`q`,但是不会打印模的内容
- `r filename`: 读取文件
- `R filename`: 每次循环插入文件中的一行
- `s/regexp/replacement/[flags]`: 对模进行正则匹配替换
- `t label`: (有点概念还不清楚)
- `T label`: 
- `v [version]`: 如果没开启或者版本不够则sed fails
- `w filename`: 将模写入到文件
- `W filename`: 模中第一行写到文件
- `x`: 切换模和暂存空间中的内容
- `y/src/dst/`: 
- `z`: 清空模中的内容
- `#`: 注释,知道下一行
- `{ cmd ; cmd ... }`: 将一些命令归为一组
- `=`: 打印当前的输入行(加上换行)
- `: label`: 指定分支命令label的位置

s命令
---
- 类似vim的`\1`这种的(1-9)
- GNU拓展
	- `\L`: 替换部分转为小写,直到`\U`或者`\E`
	- `\l`: 将下一个字符转为小写
	- `\U`: 转大写,知道`\L`或者`\E`
	- `\u`: 下一个字符转小写
	- `\E`: 停止转换
- `flags`:
	- `g`: 替换作用于所有匹配点
	- `number`: 值替换第`number`个匹配点
	- `p`: 如果进行了替换,打印新的模
	- `w filename`: 如果进行了替换,则将结果写到文件,GNU拓展支持`/dev/stderr`,和`/dev/stdout`
	- `e`: 管道来自一个shell命令的输入到模,GNU拓展
	- `I`,`i`: GNU拓展,使sed以大小写敏感的方式匹配正则
	- `M`,`m`: 以多行模式匹配正则,GNU拓展

常用命令
---
- `#`: 注释,知道下一个新行
- `q [exit-code]`: 打印后退出
- `d`: 删除模,直接开始下一个循环
- `p`: 打印模到标准输出,通常只和`-n`选项一起使用
- `n`: 打印模,然后使用下一行替换模
- `{ commands }`: 命令组
不那么常用的命令
---
- `y/source-chars/dest-chars/`: 看例子,听说类似`tr`
```
$ echo hello world | sed 'y/abcdefghij/0123456789/'
74llo worl3
```
- `a text`: 在一行之后追加文本,gnu拓展
- `i text`: 行前插入文本
- `c text`: 替换文本
- `=`: 打印当前输入行号(带一个换行)
- `l n`: (末尾加上`$`,中间折断就加上`\`)
- `r filename`: 读文件
- `w filename`: 写
- `D`: 删到换行
- `N`: 模`\n`下一行->模
- `P`: 打印到换行
- `h`: 模->暂存
- `H`: 暂存`\n`模->暂存
- `g`: 暂存->模
- `G`: 暂存`\n`模->模
- `x`: 暂存<->模

sed牛逼的命令
---
通常使用这些命令是在使用awk或者perl编程..
- `: label`: 为分支命令指定`label`的位置
- `b label`: 无条件切换到`label`,缺省到下一个循环
- `t label`: 在读入上一行或者上一次切换之后有成功的替换则切换到`label`

GNU sed专有的
---
- `e [command]`
- `F`
- `Q [exit-code]`
- `R filename`
- `T label`: 跟t反的
- `v version`
- `W filename`
- `z`

多种命令语法
---
- 拜拜

地址
---
地址决定了sed命令会执行的行(范围)
- 第144行: `sed '144s/hello/world/'`
- 所有行: `sed 's/hello/world/'`
- 有apple的行: `sed '/apple/s/hello/world/'`
- 第4到17行: `sed '4,17s/hello/world/'`
- 不含apple的行: `sed '/apple/!s/hello/world/'`
- 除了4到17行: `sed '4,17!s/hello/world/'`

通过数值选择行
---
- `number`:
- `$`: 末行
- `first~step`: gnu拓展,从`first`开始的每`step`行 (`first + (n * step)`)

正则表达式地址
---
- `/regexp/`: 匹配的行,regexp中的`/`需要转义
- `\%regexp%`: (`%`可以使用任意单个字符替换),同上,但是允许使用不同的分隔符号
- `/regexp/I`,`\%regexp%I`: 大小写不敏感的方式匹配
- `M`: 多行匹配,GNU拓展

插入: `awk -F: '$7 == "/bin/bash"' /etc/passwd`: -F指定域分隔符,$7指第七个域
- 我说怎么不认识呢,原来这个不是sed......看完才反应过来

范围地址
---
- 组合使用数值和正则: `sed -n '4,/[0-9]/p'`
- `0,/regexp/`
- `addr1,+N`
- `addr1,~N`,addr1直到其后某个为N倍数的含
- addr可以是正则

正则表达式
---
`sed`中默认使用BRE
- 在GNU sed中区别BRE和ERE区别只有
	- `?`
	- `+`
	- `()`
	- `{}`
	- `\`

基本正则
---
- `*`,0+
- `.`,任意字符
- `^`,模首的换行(所以我开始哪里看到的是真的,开头也有空字符?(好像我记错了)),就是行首
- `$`,行尾
- `[list]`,`[^list]`: 列表,匹配其中任意一个字符
- `\+`,1+,gnu拓展
- `\?`,1-,GNU拓展
- `\{i\}`,=i次
- `\{i,j\}`,i-j
- `\{i,\}`,i+
- `\(regexp\)`,捕获,和限定符组合
- `regexp1\|regexp2`,匹配两者中的一个
- `regexp1regexp2`,匹配两者组合
- `\digit`,匹配第`digth`个捕获组
- `\n`,匹配换行
- `\char`,匹配一个字符(就是转义)

拓展正则
---
啦啦啦

字符类和括号表达式
---
- `[:alnum:]`
- `[:alpha:]`
- `[:blank:]`
- `[:cntrl:]`
- `[:digit:]`
- `[:graph:]`
- `[:lower:]`
- `[:print:]`
- `[:punct:]`
- `[:space:]`
- `[:upper:]`
- `[:xdigit:]`
- 要在括号表达式中加入到`[`得第一个就加进去
- `^`非集
- `-`范围
- `[.`,`[=`,`[:`

正则表达式拓展
---
- `\w`,word
- `\W`,非word
- `b`,word边界
- `B`,除了word边界
- `\s`,匹配空白字符
- `\S`,匹配非空字符
- `\<`,匹配word首
- `\>`,匹配word尾
- `\(backtick)`,模开头,在多行模式中和^是不同的
- `\'`,模尾,在多行模式中和$是不同的

向后引用
---
- 可以出现在正则表达式中也可以出现在替换部分中~~~

逃脱序列
---
- `\a`,7
- `\f`,12
- `\n`,10
- `\r`,13
- `\t`,9
- `\v`,11
- `\cx`,ctrl-`x`
- `\dxxx`,十进制xxx
- `\oxxx`,八进制xxx
- `\xxx`,十六进制xxx
- (`\b`就省略了,因为和字界限冲突)

多字节字符和locale之类的
---
- 多字节字符处理和locale有关
- 不管

sed是怎么工作的
---
这个一看就是重点啊
- 两个数据buffer: 主要的模空间,以及,以及辅助的暂存空间
- sed通过对每一行输入执行以下循环来操作:
	- 首先,从输入流读取一行,移除末尾的换行,将他加入模空间
	- 然后,执行命令,每一个命令都可以有一个关联的地址:地址就是一种条件,命令只在和条件才执行
	- 当到达脚本尾的时候,如果没有使用`-n`选项,模空间的内容会打印到输出流,然后加上一个换行(如果移除了)
	- 在新的输入行行继续执行新的循环
- 除非使用了特殊的命令(像`D`),模空间在连个循环之间会被删除
- 而暂存空间,则在两个循环之间保持它的数据~~

多行处理技术
---
使用DGHNP来处理多行
- 慢慢体会

分支和流控制
---
- b,t,T命令允许改变sed程序的流程

限制
---
注意有些实现可能限制了行长度(模式空间和暂存空间)至不超过4000字节,POSIX标准指定至少8192字节行长度
- GNU sed没有內建限制,只要它还可以使用`malloc()`分配空间就行

> done at 2018-11-1
