# awk
---

上来就是一个总结
---
- awk中程序由`pattern-action`对构成
- 没有`pattern`的`action`总是会运行.没有`action`的`pattern`的默认`action`是`{print $0}`
- 使用特殊`#!`打头行来创建直接执行的awk程序
- awk中注释由`#`开始
- 在将awk用作一个长的shell脚本的一部分的时候要注意引用问题
- 可以使用`\`开继续一个源代码行.在`,`,未闭合的大括号,`?`,`:`,`||`,`&&`,`do`和`else`之后的行会自动继续

调用
---
- `-F`,`--field-separator fs`,将FS变量设置为`fs`
- `-f`,`--file source-file`,从`source-file`中读取awk程序
- `-v`,`--assign var=val`,在程序执行之前将变量`var`值设置为`val`
- `-W gawk-opt`,提供了一个实现专有的选项
- `--`,命令行选项结束,接下来的参数不会当做选项
- `-b`,`--characters-as-bytes`,将所有输入数据当做单字节字符
- `-c`,`--traditional`,指定兼容模式
- `-C`,`--copyright`,打印gpl
- `-d`,`--dump-variables[=file]`,全局变量,类型,最终值打印到`file`
- `-D`,`--debug[=file]`,开启调试模式
- `-e`,`--source program-text`,提供代码
- `-E`,`--exec file`,类似`-f`,从`file`中读取awk程序
- `-g`,`--gen-pot`,分析源代码并且生成GNU `gettext`可移植的对象模版文件
- `-h`,`--help`,
- `-i`,`--include source-file`,从`source-file`中读入awk源代码库,等于在程序中使用`@include`伪指令
- `-l`,`--load ext`,加载动态拓展
- `-L[value]`,`--lint[=value]`,不可移植到其他`awk`实现的构造
- `-M`,`--bignum`,选择算数精度
- `-n`,`--non-decimal-data`,开启输出数据中八进制和十六进制值的自动解释
- `-N`,`--use-lc-numeric`,在解析数值输入的时候强制使用locale的十进制小数点
- `-o`,`--pretty-print[=file]`,开启awk程序的pretty-printing
- `-O`,`--optmize`,开启gawk对程序内部表示的默认优化
- `-p`,`--profile[=file]`,开启awk程序的分析
- `-P`,`--posix`,以严格POSIX模式操作
- `-r`,`--re-interval`,允许正则表达式中的interval表达式,现在是gawk默认的行为
- `-s`,`--sandbox`,禁用`system()`函数
- `-t`,`--lint-old`,lint
- `-V`,`--version`.版本信息

命名标准输入
---
- 使用`-`指明标准输入

环境变量
---
......

包含其他文件
---
- `@include`

加载动态拓展
---
- `@load`

过时选项
---

未记载的选项和特性
---
看源代码!傻吊

总结
---
- 使用`awk 'program' files`,或者`awk -f program-file files`来运行awk
- 所有版本awk的三个选项,`-f`,`-F`,和`-v`
- 非选项命令行参数通常当做文件名,除非是`var=value`的形式
- 除了程序文本之外的命令行参数,都置于ARGV数组
- 使用单个`-`来在命令行引用标准输入
- `gawk`使用了一些环境变量,`AWKPATH`,`AWKLIBPATH`,`POSIXLY_CORRECT`是最重要的
- 退出状态传递给调用的程序
- 允许在程序中使用`@include`或者在命令行使用`-i`,`-f`选项
- 允许使用`@load`语句或者`-l`选项加载用C或C++写的额外函数

正则
---
- 正则常量写在`//`中
- 正则可以单独用在模式或者条件表达式中,或者作为使用`~`和`!~`运算符的表达式的一部分
- 逃脱序列
- 分组,替换,重复
- 从左最长匹配
- 可以使用动态正则匹配表达式
- 草拟吗垃圾

读取输入文件
---
正文开始
- 从标准输入或者文件中读取.如果指定了输入文件,按顺序读取,以一个处理数组
- 读入的数据单元叫做记录,每次按照你的规则处理一条记录,默认一条记录是一行,这样跟方便程序处理部分记录
- 在少数情况下,可能需要使用`getline`命令

输入如何拆分成记录
---
awk将你程序的输入拆分成记录和域.它会保持跟踪你已经从当前输入文件中读入的记录条数.这个值保存在一个叫做`FNR`的预定义变量中,每次开始处理一个新文件就会置零.另一个预定义的变量,`NR`,记录从数据文件中已经读取的记录总数.从零开始,不会自动重置

记录分隔符
---
- 记录由一个叫做记录分隔符的字符分隔,可以使用预定义变量`RS`来使用别的记录分隔符
- RS使用""的时候有特殊意义,表明记录由一个或者过个空行分隔
- RS只会影响之后的记录处理
- 上面是awk的,还有gwak的不看了

检查域
---
- 当awk读取一条输入记录的时候,记录会自动被awk解析或者拆分成叫做域的块.默认域由空白字符分隔
- awk中的空白字符表示一个或者多个空格,TAB,换行组成的串
- 使用`$`来在awk程序中引用一个域,$1是第一个域,类推
- `NF`是预定义变量,它的值是当前记录中域的数目,最后一个域总是可以使用`$NF`表示
- 试图访问不存在的域会获得空串(如果用在数值操作中,将得到0)
- `$0`表示整条输入记录

非常量域值
---
- 域值不一定要是一个常量,awk语言中任何变量都可以用在`$`之后来引用一个域

改变域的内容
---
- awk所看到的域的内容,可以在awk程序中改变,这会改变awk当前所感知的输入记录(不会懂实际的输入,awk绝对不会改输入文件)
- 改变FS或者NFS需要一定动作来强制重组记录

指定域分隔符
---
- 默认使用空白字符
- 使用正则表达式分隔
- FS赋值""使用单个字符做域
- `awk -F, 'program' input-files`,在输入行指定域分隔符
- `awk -F'\n' 'program' files …`,整行做域

读取固定长度的记录
---
- 跳过

打印输出
---
- 我不想学一门编程语言,,gnu有时候有点不务正业啊

以后再说
---

函数
---
抄点函数
- `int(x)`,向0取整
- (其实就是c那些)
- `asort`,`asorti`排序
- `close`,关闭文件
- `print`,好像是前面printing介绍的,拜拜
